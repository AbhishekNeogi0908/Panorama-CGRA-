Kernels with if-else
====================

-------------------------------------------------------------------------------------------
1)ReluQuantized :- Done


void ReluQuantized(int lower,int output_data[IMAGE_SIZE]) {
     for (int i = 0; i < IMAGE_SIZE; ++i) {
        output_data[i] = (input_data[i] < lower) ? lower : input_data[i];
     }


}

For IMAGE_SIZE = 20 (k=20), II = 4, Latency = 17, Time measured = 10.1865seconds
Total execution time   = (k-1)*II + L
			= 93 cycles  

------------------------------------------------------------------------------------
2)Relu6Quantized :- Done

 void Relu6Quantized(int lower, int upper, int output_data[], int size) {

     for (int i = 0; i < size; ++i) {
         int val = input_data[i];
         int clamped = (val > upper) ? upper : (val < lower ? lower : val);
         output_data[i] = clamped;
     }

 }
For IMAGE_SIZE = 20 (k=20), II = 4, Latency = 20, Time measured = 16.1888sec
Total execution time   = (k-1)*II + L
			= 96 cycles  
------------------------------------------------------------------------------------
3)LeakyRelu :- Done

void LeakyReluInt(int alpha, int scale,  int output_data[], int size) {
     int out;
	 for (int i = 0; i < size; ++i) {
         int val = input_data[i];
         if (val > 0) {
             out = val;
         } else {
             out = (val * alpha);
         }
         output_data[i]=out;
     }

 }
 
For IMAGE_SIZE = 20 (k=20), II = 4, Latency = 16, Time measured = 8.74868sec
Total execution time   = (k-1)*II + L
			= 92 cycles 
-------------------------------------------------------------------------------------
4)AffineQuantize :- Done


void AffineQuantize(int zero_point, int scale, int output_data[], int size,int min_val,int max_val) {

    for (int i = 0; i < size; i++) {
        int val = input_data[i];
        int unclamped = (val * (1<<16) + ((1>>1)*(1<<16))) + zero_point; 
       
        int clamped;
        if (unclamped < min_val) {
            clamped = min_val;
        } else if (unclamped > max_val) {
            clamped = max_val;
        } else {
            clamped = unclamped;
        }

        output_data[i] = clamped;
    }

}
NOTE : The dfggenpass cannot handle such complex calc. of unclamped. Hence calculate separetly in another for loop

For IMAGE_SIZE = 20 (k=20), II = 4, Latency = 7, Time measured = 3.42587sec
Total execution time   = (k-1)*II + L
			= 83 cycles 


Kernels without if-else
=======================
--------------------------------------------------------------------------------
5)Dequantize :- Done

void Dequantize(int flat_size,int output_data[MAX_ARRAY_SIZE],int zero_point, int scale) {
    for (int i = 0; i < flat_size; i++) {
             output_data[i] = (scale * (input_data[i] - zero_point) );

    }
}

For IMAGE_SIZE = 20 (k=20), II = 4, Latency = 12, Time measured = 7.58268sec
Total execution time   = (k-1)*II + L
			= 88 cycles 

-------------------------------------------------------------------------------
6)MatrixVectorMultiply :- DONE :- Declare the result array within the function and not in function argument

void MatrixVectorMultiply(int num_filters,int result[MAX_NUM_FILTERS]) {
     for (int j = 0; j < num_filters; ++j) {
         int dot_prod = 0;  
         for (int k = 0; k < INPUT_SIZE; ++k) {
             dot_prod += matrix[j][k] * vector[k];
         }
         result[j] = dot_prod;  

     }
 }

-----------------------------------------------------------------------------
7)PortableCwiseMul :- Done

void PortableCwiseMul( int shift, int output[]) {
   for (int i = 0; i < FLAT_SIZE; ++i) {
       int a = input_1[i];
       int b = input_2[i];
       int value = a * b; 
       output[i] = value >> shift; 
   }
 }

For FLAT_SIZE = 20 (k=20), II = 4, Latency = 14, Time measured = 8.23038sec
Total execution time   = (k-1)*II + L
			= 90 cycles 
------------------------------------------------------------------------			
			
8)FullyConnected :- 
-----------------
void FullyConnected(
     const int input_offset, const int filter_offset, const int output_offset,
     const int output_multiplier, const int output_shift,
     const int output_activation_min, const int output_activation_max,
     const int input_size,  const int output_depth, const int accum_depth,
     const int bias_data, int* output_data) {


 
     for (int out_c = 0; out_c < output_depth; ++out_c) {
         int acc = 0;
         for (int d = 0; d < accum_depth; ++d) {
             int input_val = input_data[d];
             int filter_val = filter_data[out_c][d];
             acc += (filter_val + filter_offset) * (input_val + input_offset);
         }


             acc += bias_data;
             int reduced_multiplier = (output_multiplier + (1 << 15)) >> 16;
             int total_shift = 15 - output_shift;
             acc = (int)acc * (int)reduced_multiplier + ((int)1 << (total_shift - 1));
             acc >>= total_shift;
             acc += output_offset;

         int min_diff = acc - output_activation_min;
         int max_diff = output_activation_max - acc;
         acc = acc + (min_diff & (min_diff >> 31)) + (max_diff & (max_diff >> 31));
         output_data[out_c] = acc;
     }


 }

9)PortableMatrixScalarAccumulate :- Done
---------------------------------
 void PortableMatrixScalarMultiplyAccumulate(
                                             int scalar, int n_row,
                                             int n_col, int output[]) {

     for (int i = 0; i < n_row; ++i) {
         int row_sum = 0;
         for (int j = 0; j < n_col; ++j) {
             row_sum += matrix[i][j];  
         }
         output[i] += row_sum * scalar;
     }
 }

10)Matmul :- Done
----------
void MatMul(const int lhs_rows, const int lhs_cols,
             const int rhs_rows, const int rhs_cols,
             int output_data[lhs_rows][rhs_cols]) {


     for (int i = 0; i < lhs_rows; ++i) {
         for (int j = 0; j < rhs_cols; ++j) {
             int total = 0;
             for (int k = 0; k < lhs_cols; ++k) {
                 total += lhs_data[i][k] * rhs_data[k][j];  
             }
             output_data[i][j] = total;
         }
     }

 }
 
